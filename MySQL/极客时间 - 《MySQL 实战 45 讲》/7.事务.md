begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令

1. 第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的
2. 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的

# “快照”在 MVCC 里是怎么工作的

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715150790669-e0aa69be-8068-4599-bfa2-d2f03ff26658.png)图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）

而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715151271842-50446ee8-a51e-4ce7-90b9-3b9e3027ee69.png)对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的
3. 如果落在黄色部分，那就包括两种情况

1. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见
2. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见

**InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力**

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1. 版本未提交，不可见
2. 版本已提交，但是是在视图创建后提交的，不可见
3. 版本已提交，而且是在视图创建前提交的，可见

# 更新逻辑

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715152003494-42455fce-3a44-45e3-82d7-1ffc66dbd28c.png)

**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）**

这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715152444934-de2b12e0-f8c5-4678-be58-c7780b221f40.png)

# 事务的可重复读的能力是怎么实现的？

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待