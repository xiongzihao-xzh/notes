# 索引的常见模型

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715133930403-9e557977-359e-4654-9a09-db6e0baac22f.png)图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。所以，哈希表这种结构适用于只有等值查询的场景

有序数组在等值查询和范围查询场景中的性能就都非常优秀

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715134394929-58ce2492-f4fa-4bec-98a9-eb6c6502530b.png)但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于静态存储引擎（这类不会再修改的数据）

用二叉搜索树来实现的话，示意图如下所示：

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715134903922-6436ddeb-330e-4fef-868e-c9685a76241f.png)二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小

N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了

# InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715135837852-67c39c88-27ba-42c4-af15-d8b4dcccf1cf.png)

根据叶子节点的内容，索引类型分为主键索引和非主键索引：

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）

基于主键索引和普通索引的查询区别：

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵B+ 树
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表

# 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置

而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小

业务字段直接做主键的情况：

1. 只有一个索引
2. 该索引必须是唯一索引

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715141781149-4d5e6a3b-91f4-4568-b837-45726dd02ddd.png)这条 SQL 查询语句的执行流程：

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300
2. 再到 ID 索引树查到 ID=300 对应的 R3
3. 在 k 索引树取下一个值 k=5，取得 ID=500
4. 再回到 ID 索引树查到 ID=500 对应的 R4
5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，我们称为回表

# 覆盖索引

如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，**索引 k 已经“覆盖了”我们的查询需求**，我们称为覆盖索引

# 最左前缀原则

只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符

# 索引下推

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715144651349-d56b45b4-483c-44eb-9710-a7aaccb91e4e.png)![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715144655145-15d45763-489e-4fad-a62e-237a0091ddaa.png)