![[Index Nested-Loop Join 算法的执行流程 20240509215609.png]]
在这个 join 语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索
假设被驱动表的行数是 M。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。 每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2 M，所以在被驱动表上查一行 的时间复杂度是 2\*log2M
假设驱动表的行数是 N，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹 配一次
因此整个执行过程，近似复杂度是 N + N*2*log2M
显然，N 对扫描行数的影响更大，因此应该让小表来做驱动表
通过上面的分析我们得到了两个结论：
1. 使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好
2. 如果使用 join 语句的话，需要让小表做驱动表
这个结论的前提是“可以使用被驱动表的索引”
被驱动表上没有可用的索引，算法的流程是这样的：
![[Block Nested-Loop Join 算法的执行流程 20240509220609.png]]
算法的流程是这样的：
1. 把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select \*，因此 是把整个表 t1 放入了内存
2. 扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件 的，作为结果集的一部分返回。
# 能不能使用 join 语句？
1. 如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的
2. 如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操 作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要 用
所以你在判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现 “Block Nested Loop”字样
# 如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？
1. 如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表
2. 如果是 Block Nested-Loop Join 算法：
	1. 在 join_buffer_size 足够大的时候，是一样的
	2. 在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表
这个问题的结论就是，总是应该使用小表做驱动表
**在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表**
