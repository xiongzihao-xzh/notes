# 全字段排序

```
select city,name,age from t where city='杭州' order by name limit 1000;
```

通常情况下，这个语句执行流程如下所示 ：

1. 初始化 sort_buffer，确定放入 name、city、age 这三个字段
2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id
3. 到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中
4. 从索引 city 取下一个记录的主键 id
5. 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y
6. 对 sort_buffer 中的数据按照字段 name 做快速排序
7. 按照排序结果取前 1000 行返回给客户端

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715222958232-1a703b62-6398-4901-abd5-cafb275febc4.png)图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size

sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序

# rowid 排序

单行长度太长 MySQL 会采用 rowid 排序

1. 初始化 sort_buffer，确定放入两个字段，即 name 和 id
2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X
3. 到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中
4. 从索引 city 取下一个记录的主键 id
5. 重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y
6. 对 sort_buffer 中的数据按照字段 name 进行排序
7. 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端

![](https://cdn.nlark.com/yuque/0/2024/png/22909600/1715223537433-0219fa6d-ec57-4365-90af-192aa120c7b7.png)最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的