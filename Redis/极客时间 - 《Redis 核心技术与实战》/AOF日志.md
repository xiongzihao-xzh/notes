目前，Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照
AOF 是写后日志，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些 命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中。
AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作
AOF 日志也是在主线程中执行的
![[Redis AOF 操作过程 20240422234630.png]]
![[Redis AOF 日志内容 20240422234746.png]]
# 三种写回策略
* Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘
* Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每 隔一秒把缓冲区中的内容写入磁盘
* No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲 区，由操作系统决定何时将缓冲区内容写回磁盘
![[三种写回策略 20240423002356.png]]
# AOF 重写机制
AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件， 也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入
![[AOF重写减少日志大小 20240423002829.png]]
和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是 为了避免阻塞主线程，导致数据库性能下降
## 一个拷贝，两处日志
“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此 时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新 数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成 操作，记入重写日志
因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在 使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复
而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样， 重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的 这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用 新的 AOF 文件替代旧文件了
![[AOF 非阻塞的重写过程 20240423003424.png]]
