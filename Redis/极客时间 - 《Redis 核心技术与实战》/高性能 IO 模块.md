Redis 是单线程，主要是指 Redis 的网络 IO 和 键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的
![[线程数和系统吞吐量 20240407001015.png]]
采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码 的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式
# 基本 IO 模型与阻塞点
监听客户端请求 （bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户 端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。bind/listen、accept、recv、parse 和 send 属于网络 IO 处 理，而 get 属于键值数据操作
![[Redis 基本 IO 模型 20240407001552.png]]
在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听 到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导 致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据 时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()
# 基于多路复用的高性能 I/O 模型
Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套 接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到 达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果
下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定 的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为 此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性
![[基于多路复用的Redis高性能IO模型 20240407003958.png]]
为了在请求到达时能通知到 Redis 线程，**select/epoll 提供了基于事件的回调机制，即针对不 同事件的发生，调用相应的处理函数**
